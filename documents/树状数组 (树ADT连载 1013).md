树状数组 (树ADT连载 10/13)

本文将依次讲解如下内容。

1. 基本的树状数组 (PURQ BIT) : 以 O(*logn*) 复杂度解决长度为 n 的序列的 单点修改 及 区间查询 问题。

2. 区间划分： 从区间查询出发，思考如何利用类似倍增思想那样的做法来划分子区间，从而提高区间查询的效率。
3. lowbit: 通过对 *nums* 下标二进制形式的观察，寻找一种将输入序列划分为 n 个子区间的方式。链接子区间及包含它的更大一点的子区间后，这些子区间构成一棵逻辑上的 「二元索引树」 。
4. 时间复杂度分析： 单点修改及区间查询的时间复杂度都与 (n)^2 的位数相关，简单分析后可知它们都是时间为 O(*logn*) 的操作。
5. RUPQ BIT： 在 PURQ BIT 的基础上，引入 差分数组 ，实现 RUPQ BIT。
6. RURQ BIT： 在 RUPQ BIT 的基础上，根据 算式推导 ，引入 辅助树状数组 ，实现 RURQ BIT。




1. 树状数组 (树ADT连载 10/13)
   1. 树状数组
      1. PURQ BIT (单改区查)
         1. 区间划分
            1. lowbit
         2. 单点修改
         3. 区间查询
         4. 初始化
         5. 时空复杂度
         6. 类的实现代码
      2. RUPQ BIT (区改单查)
         1. 差分数组
         2. 从PURQ到RUPQ
         3. 时空复杂度
         4. 类的代码实现
      3. RURQ BIT (区改区查)
         1. 从RUPQ到RURQ
         2. 时空复杂度
         3. 类的实现代码
      4. 小结
      5. 实战应用
         1. 区间内在给定取值范围内的元素数
         2. 松离散与紧离散
         3. 题目

**树状数组**

树状数组 (二元索引树 / 二元下标树 / Binary Indexed Tree, BIT, Fenwick Tree): 树状数组虽名为数组，但从其英文名可看出它实际上是一种被表达为树的数据结构，对于大小为 n 的序列 *nums* 的单个元素更新以及区间求和操作，时间复杂度都是 O(*logn*) 。最基本的树状数组支持 *nums* 上的这两种操作。

- 更新 *nums* 中单个元素的值，即 单点修改 。

- 求 *nums* 任意区间的元素值之和，即 区间查询 。

这是两种非常简单的操作，最简单的做法是直接操作 nums ，单点修改的时间复杂度为 O(1) ，区间查询为 O(n)。此外，利用「前缀和」，我们也可以先用 nums 计算出前缀和数组 preSum ，那么求 [l , r][l,r] 区间和，即是preSum[r+1] - preSum[l]preSum[r+1]−preSum[l] ( preSum[0]=0, preSum[1]=nums[0]preSum[0]=0,preSum[1]=nums[0] )，时间复杂度为 O(1) 。但单点修改 nums[i] 要求 preSum[i+1]preSum[i+1] 及之后的前缀和元素都要相应更新 (否则之后求区间和会出错)，这使得单点修改时间复杂度为 O(n)O(n) 。

无论是使用普通数组还是利用前缀和数组，对于上述两种操作，均有一种的时间复杂度为 O(n) 。而树状数组通过维护一个与 nums 等大的 (有效元素个数相同)，在逻辑上为树状结构的数组 tree[] ，能够实现两种操作的时间复杂度均为 O(logn) 。



序列操作	数组	前缀和	树状数组
单点修改	O(1)O(1)	O(n)O(n)	O(logn)O(logn)
区间查询	O(n)O(n)	O(1)O(1)	O(logn)O(logn)
与 并查集 一样， 树状数组是一种极具巧思，代码实现极轻巧却不失高效的数据结构 。我们马上会看到树状数组如何借助 二进制形式的 numsnums 的下标值 ([1,n][1,n]) ，将 numsnums 划分为多个子区间，这些子区间构成逻辑树形结构，利用树的特点使得两种基本操作都复杂度都是 O(logn)O(logn) 。

为方便后续行文，我们提前介绍如下操作，并约定称呼及简称。

操作	定义
单点修改 (Point Update, PU)	修改 numsnums 的单个元素
单点查询 (Point Query, PQ)	查询 numsnums 的单个元素
区间修改 (Range Update, RU)	修改 numsnums 的某个区间
※ 区间元素都加上同一个数
区间查询 (Range Query, RQ)	求 numsnums 的某个区间的区间和
根据 wiki，树状数组最早由 Boris Ryabko (前苏联) 于1989年 提出 ，并在1992 年发表了一个 改进版本 。 Peter Fenwick 在其1994年的 文章 中描述了该数据结构，随后此数据结构便以 Fenwick tree 之名广为人知。

This structure was proposed by Boris Ryabko in 1989[1] with a further modification published in 1992.[2] It has subsequently become known under the name Fenwick tree after Peter Fenwick, who described this structure in his 1994 article.[3]

作者的「树状数组」知识，最初学自 OI wiki 树状数组。



PURQ BIT (单改区查)
最基本的树状数组是支持「单点修改 (PU)」和「区间查询 (RQ)」的 PURQ BIT。



区间划分
使用普通数组或利用前缀和数组实现 PU/RQ 两种操作时，均有一种操作需要遍历 一段连续的区间，在 numsnums 上的「连续」操作使得时间复杂度为 O(n)O(n) 。为了提高操作效率，我们必须减少操作的次数。首先考虑求长度为 kk 的区间的区间和操作，我们会想，如果不是连续地相加 kk 次，而是通过某种预先处理的手段，将大小为 kk 的区间 划分为多个子区间 ，子区间个数少于 kk ，每一个子区间的区间和都被实时维护，那么求区间和时，就只需要执行少于 kk 次的相加了 (子区间的区间和相加)。例如下图，当我们求 numsnums 区间 [4, 9][4,9] (下标从1开始) 的区间和时，如果我们能通过某种方式，找到子区间1 [4,5][4,5] 、 子区间2 [6,8][6,8] 、子区间3 [8,8][8,8] ，且这些子区间的区间和总是能够被实时维护，那么只需3次相加即可得到要求的区间和 0+5+19+8=320+5+19+8=32。



那么树状数组是这一想法的实现吗？答案是：不完全是。 树状数组确实将 numsnums 划分成了多个区间，但并不是对任意区间 [l,r][l,r] 划分连续子区间，而是通过「前缀区间和」做差的方式来得到指定区间的「区间和」。我们提前指出，树状数组这一数据结构，对输入数组 numsnums 划分为多个子区间，使得对任意的 [0,k][0,k] 前缀区间，都可以由划分结果中的若干个连续的子区间构成，代表每个子区间的区间和相加即可得到「前缀区间和」。对于任意区间 [l,r][l,r] ，将右界前缀区间 [0, r][0,r] 的区间和减去左界前一位的前缀区间 [0,l-1][0,l−1] 的区间和，即为 [l,r][l,r] 区间和。

区间划分的思考也许会让你想到利用「倍增思想」的快速幂算法 leetcode #50-pow(x, n) ，该算法不是通过「连续」地将 xx 相乘 nn 次，而总是借助已经算出的结果来快速得到新的更大范围的中间结果，这个中间结果又能用于之后求更大范围的结果的计算中。实际上除了倍增思想，ß动态规划、记忆化搜索都体现了这种 「从已完成的处理开始下一步处理」 的思想。现在，我们重新将 树状数组解决区间和问题 的灵感来源描述如下:

numsnums 上任意 [l, r][l,r] 的区间和，将通过 [0,r][0,r] 和 [0, l-1][0,l−1] 的区间和 (前缀和) 做差得到。
前缀区间由若干个相邻的子区间构成，这些子区间的区间和相加得到前缀区间的区间和。
所有的子区间，是根据 numsnums 下标的二进制表示来划分的。
很抽象，尤其是最后一句，无法得知如何处理下标的二进制数来得到子区间划分，不过没关系，我们马上对大小为 8 (下标范围为 [1,8][1,8])的 numsnums 实践上述描述。 首先明确为了实现「更快地求区间和」的需求：

※ 这里要注意下标，原本输入数组 numsnums 的下标为 [0,n-1][0,n−1] ，但我们先将其看作 [1,n][1,n] ，后面你会知道为何要这样处理。

将指定长度的 numsnums 划分为若干区间。对 numsnums 下标的划分动作应当是一种 可循环的操作 。
numsnums 上的任意区间 [l, r][l,r] 的区间和可由 [1,r][1,r] 区间和与 [1,l-1][1,l−1] 区间和做差得到，这是「前缀和」的思想。这要求 [1, l-1], [1,r][1,l−1],[1,r] 均由 numsnums 划分结果中的若干 相邻区间 所构成。从这里可以看出， 对 numsnums 的划分，不只是对 [1,n][1,n] 的划分，而是对 [1,k](k∈[1,n])[1,k](k∈[1,n]) 的划分，划分后，一定能由若干连续区间构成任意的 [1,k](k∈[1,n])[1,k](k∈[1,n]) 。
子区间的区间和被 实时维护 。需要用一个 tree[]tree[] 数组保存这些子区间和 (我们马上会知道为什么命名为 treetree)。
求给定区间的区间和，即求两次前缀区间和再做差。求前缀区间和需要通过 某种规则 一边寻找其子区间 ii ，一边将 tree[i]tree[i] 累计到结果中。
更新 nums[i]nums[i] 时，通过 某种规则 更新包含该值的所有子区间的区间和。
前述描述的后半句提到了「二进制表示」，以划分区间 [1,7][1,7] 为例，我们先写出 7 的二进制表示 7=(111)_27=(111) 
2

  。我们要求划分动作是可循环的操作，且对于任意长度的 numsnums，都能通过同样的方式完成划分。显然，区间 [1,7][1,7] 的最右子区间的右界是 7 ，最左子区间的左界是 0 (开区间，稍后可知子区间为何是左开右闭形式) 。我们将最右子区间作为当前区间，从当前子区间右界下标 7 开始考虑。

一个容易想到的方法是，每次都将当前子区间右界下标最低位的 1 换成 0 ，作为当前区间的左界下标，同时也是其 左邻子区间的右界下标 ，重复该操作直到当前区间右界下标为 0 (二进制数所有位都没有 1) ，这时候划分就完成了。于是区间 [1,7][1,7] 被划分为这三个左开右闭区间 ((000)_2,(100)_2]((000) 
2

 ,(100) 
2

 ] , ((100)_2,(110)_2]((100) 
2

 ,(110) 
2

 ] , ((110)_2,(111)_2]((110) 
2

 ,(111) 
2

 ] ，即 (0,4](0,4] , (4,6](4,6] , (6,7](6,7]。一番验证后，我们发现，这样的区间划分方式完全符合前述 5 点要求，具体如下。

规则是固定的，因此操作是可循环的，通过这种方式，我们一定能够将 numsnums 的任意 [1, k][1,k] 区间划分为一些子区间。 也容易看出，[1,k][1,k] 无论怎么划分，一定有且只有一个以 kk 为右界的子区间。kk 的取值有 nn 种，因此 长度为 nn 的 numsnums 划分出 nn 个子区间 ，这些子区间的右界是 \{1,2,3,...,n\}{1,2,3,...,n} ，左界是 \{1-lowbit(1),2-lowbit(2),3-lowbit(3),...,n-lowbit(n)\}{1−lowbit(1),2−lowbit(2),3−lowbit(3),...,n−lowbit(n)} (lowbit(i)lowbit(i) 就是最低位的 1 代表的数字，后续介绍其实现)。
根据1，对于任意的 [l,r][l,r] ，一定有对应的 [1,l-1][1,l−1] 和 [1,r][1,r] ，将二者的区间和做差即可得到 [l,r][l,r] 的区间和。
单点修改会导致包含被修改的元素值的区间的区间和发生变动，需要对这些区间的区间和做同样的更新操作。现在我们还不知道要怎么找 「包含给定元素的所有区间」 ，留到后续说明。
「将当前子区间右界下标最低位的 1 换成 0」的划分方式即为该规则。
同3，后续说明。
根据上述1，我们得知 tree[]tree[] 的大小为 n+1n+1，因为划分的 nn 个子区间的右界元素都唯一地存在于该区间中，当我们要表达这些区间 (的区间和 tree[]tree[] ) 时，可由区间右界作为 tree[]tree[] 的下标，例如 tree[5]tree[5] 指的是右界为5的区间的区间和 (只有该区间包含了 numsnums 中的第 5 个元素)，或者也可以说是 numsnums 的第5个区间的区间和 (注意，tree[0]tree[0] 无意义)。另外，左界中的 i-lowbit(i)i−lowbit(i) 就是我们介绍的划分方式的位运算实现，下面先介绍 lowbitlowbit 方法。

还是抽象？再坚持一下，lowbitlowbit 之后上图。



lowbit
前面我们说过「将当前子区间右界 ii 的二进制表示中最低位的 1 换成 0 后作为该子区间左界，也即其左邻子区间右界 (更新 ii )」，在代码中我们通过巧妙的位运算来实现 ii 的这一更新。 下图以两个例子 (110101, 101000) 展示这一运算过程，也即下式。

i=i\&(\sim i+1)
i=i&(∼i+1)



正数 ii (「下标」大于等于1，必为正) 的相反数 -i−i 是负数，我们知道，负数在计算机中以补码 (two's complement) 表示，负数 -i−i 的补码为对应正数 ii 的除符号位外按位取反后再加1，即 -i=\sim i+1−i=∼i+1 ，恰好与上述式子与运算 \&& 的右边相同，于是我们给出如下 lowbit(i)lowbit(i)方法，如其方法名所表达的那样， 该方法返回下标 ii 的二进制表示中的最低位的 1 所代表的数 。后续我们可以用该方法方便地对当前子区间右界 ii 求其左界，即其左邻子区间右界 ( i-lowbit(i)i−lowbit(i) )。


private int lowbit(int i){
    return i & -i;
}
下图展示了大小为 16 的 numsnums (图中的 aa 数组) 的子区间划分，t[]t[] 即 tree[]tree[] ，16个矩形代表划分出的16个子区间，tree[]tree[] 的大小为 n+1=17n+1=17 ，有效区间和元素下标范围为 [1, 16][1,16] 。tree[1]tree[1] 表示右界为 numsnums 第 1 个元素的区间的区间和，tree[2]tree[2] 表示右界为 numsnums 第 2 个元素的区间的区间和，依次类推。蓝线表示 区间包含关系 。单点修改操作需要更新所有包含修改点的区间的区间和，寻找包含修改点的区间的过程就是 沿着蓝线向上 的过程。将该图稍作调整即可得到下一张更标准的树形图。到这里，相信读者们应该对「树状数组」和 「Binary Indexed Tree」有了更深的理解。需要强调的是，treetree 所代表的逻辑树并非二叉树，英文名称中的 binary 指的是下标二进制表示中的 0 或 1，表达的是下标二进制数位的 01 变化，与 treetree 逻辑结点的索引关系。





接下来我们分析如何实现「单点修改」和「区间查询」，分析过后你会知道之前需求 3 和 5 是如何被满足的。



单点修改
更新 numsnums 的第 kk 项 (nums[k - 1]nums[k−1]) ，需要相应地更新包含它的所有区间的区间和 tree[]tree[] 。通过前面的树状图，我们不难看到，第一个要更新的区间和一定是 tree[k]tree[k] (图中的 a[]a[] 即为 nums[]nums[] ，注意 a[]a[] 的下标是从 1 开始的)。沿着蓝线上升，考虑蓝线连接的父子结点的下标二进制表示，我们发现包含修改点 (子结点) 的下一个更大的区间 (父结点) 的右界总是 i = i + lowbit(i)i=i+lowbit(i) ，这也是下一个包含 nums[k-1]nums[k−1] 的更大区间和逻辑结点的下标 (父结点下标)。每上升一层，就会找到包含修改点的更大范围的区间。

单点修改方法的方法签名为 public void update(int i, int val) ，表示更新 nums[i] = val ，但对于蓝色链条上的「区间和」 tree[i]tree[i] 的更新，要做的是使 tree[i]tree[i] 加上增量，即 tree[i] += val - nums[i] 。因此该 updateupdate 方法调用 private void add(int k, int x) 方法，表示为第 kk 个区间和结点的区间和加上增量 xx 。每次更新 tree[i]tree[i]，都通过调用 addadd 方法从第 ii 个区间沿着蓝色链条完成所有区间和的更新，可见 addadd 方法的主体是一个循环，蓝色链条上的区间和结点下标 ii 的更新我们已经知道，于是不难写出如下 updateupdate 和 addadd 方法。寥寥数行，配合 lowbitlowbit 向上更新，十分奇妙。


public void update (int i, int val){ // 单点修改: nums[i] = val
    add(i + 1, val - nums[i]); // 第一个包含 nums[i] 的区间对应树状数组中的第 i+1 项 tree[i+1]
    nums[i] = val; // 更新 nums[i] 为val
}
private void add(int k, int x){ // 单点修改: nums[k-1] += x (nums[k-1]是 nums 中的第 k 项)
    for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
        tree[i] += x; // 包含第k项的区间都加上x
    }
}
下图展示了 add(5,2)add(5,2) 的过程。





区间查询
给定 numsnums 上的区间 [l,r][l,r] ，求区间和。利用前缀和的思想，我们定义方法 private int query(int k) ，表示求 numsnums 的前 kk 项和，那么求 [l,r][l,r] 的区间和即为 query(r + 1) - query(l) 。在「区间划分」中我们已经知道通过 i = i - lowbit(i) 的方式从 i = r + 1i=r+1 开始依次求出组成 [0,r][0,r] 区间的子区间的右界下标，也即区间和逻辑结点 tree[i]tree[i] 的下标，依次将得到的 tree[i]tree[i] 累计即可得到要求的前缀区间和。可见 query(k) 方法的主体是一循环，循环终止条件是 i == 0 ，循环终止时求出 numsnums 的前 kk 项和，不难写出如下 sumsum 和 queryquery 方法。


public int sum(int l, int r){ // 查询区间和: 求nums[l]到nums[r]之和
    return query(r + 1) - query(l);
}
private int query(int k){ // 查询前k项和
    int ans = 0;
    for(int i = k; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
        ans += tree[i];
    }
    return ans;
}
下图展示了 query(15)query(15) 的过程。





初始化
从「区间划分」入手，我们轻松地得出了基本树状数组所要解决的单点修改和区间查询操作，但这两种操作都要建立在最初 tree[]tree[] 有值的情况下，现在我们回过头分析 tree[]tree[] 的初始化。 一开始 tree[]tree[] 所有元素值均为0，前面我们说过，单点修改 nums[i]nums[i] 时，首个需要更新的结点的区间和为 tree[i + 1]tree[i+1] ，调用 addadd 方法，更新 tree[i + 1]tree[i+1] 之后，addadd 中的 forfor 循环会沿着蓝色链条向上更新所有包含该修改点的更大的区间结点的区间和。因此， tree[]tree[] 的初始化可以按任意顺序调用 nn 次 addadd 初始化 nn 个区间和，每次调用 addadd 更新某个区间和时，总能保证受影响的更大区间和得到更新。一般我们按 1 \sim n1∼n 的顺序初始化 treetree ，在树状数组的构造器中的初始化如下。


class BIT{
    int[] nums, tree; // nums为输入数组，tree为区间和数组
    int n; // nums大小
    public BIT(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[this.n + 1];
        for(int i = 0; i < n; i++){ // 依次更新第1个到第n个区间和结点tree[i+1]
            add(i + 1, nums[i]);
        }
    }
}


时空复杂度
时间复杂度:

单点修改时间复杂度: O(logn)O(logn) 。

取决于更新结点到根结点的路径上的结点数，更新 nums[0]nums[0] 时路径上结点数最多，其数量为 tree[i]tree[i] 的下标 ii 从 (000...001)_2(000...001) 
2

  通过 i += lowbit(i)i+=lowbit(i) 逐位更新到 (100...000)_2(100...000) 
2

  的更新次数 (初始算一次)，也即 (n)_2(n) 
2

  的位数，也即 lognlogn ，因此单点修改的时间复杂度为 O(logn)O(logn)。

区间查询时间复杂度: O(logn)O(logn) 。

区间为 [l, r][l,r]。 取决于 [1,r][1,r] 区间的连续子区间个数。根据子区间界的计算方法，子区间个数与 rr 的二进制数中 1 的数量有关，假设 rr 的二进制数有 kk 位，则 n=2^k-1n=2 
k
 −1 时 1 的位数最多，共 kk 个， k=log(r+1)k=log(r+1)。根据 sumsum 方法，先求 [1,l], [1,r][1,l],[1,r] 的前缀区间和，ll 不大于 rr，时间复杂度为 O(2*logr)O(2∗logr) ，rr 最大为 nn ，因此区间查询的时间复杂度为 O(logn)O(logn)。

初始化时间复杂度： 调用 nn 次 addadd ，时间复杂度为 O(nlogn)O(nlogn) 。

空间复杂度: O(n)O(n) ，取决于 treetree 数组大小。



类的实现代码
以下是「基本树状数组」 类 BITBIT (PURQ) 的实现代码，所有方法均已分析。


class BIT{
    int[] nums, tree; // nums为输入数组，tree为区间和数组
    int n; // nums大小
    public BIT(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[this.n + 1];
        for(int i = 0; i < n; i++){
            add(i + 1, nums[i]);
        }
    }
    public int sum(int l, int r){ // 查询区间和: 求nums[l]到nums[r]之和
        return query(r + 1) - query(l);
    }
    public void update (int i, int val){ // 单点修改: 令nums[i] = val
        add(i + 1, val - nums[i]); // nums[i]对应树状数组中的第i+1项tree[i+1]
        nums[i] = val; // 更新 nums[i] 为val
    }
    private int query(int n){ // 查询前n项和
        int ans = 0;
        for(int i = n; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
            ans += tree[i];
        }
        return ans;
    }
    private void add(int k, int x){ // 单点修改: nums[k-1] += x (nums[k-1]是 nums 中的第 k 项)
        for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
            tree[i] += x; // 包含第k项的区间都加上x
        }
    }
    private int lowbit(int i){
        return i & -i;
    }
}


RUPQ BIT (区改单查)
前述基本树状数组 (PURQ BIT) 很好地支持了「单点修改」及「区间查询」操作，当我们需要更多的区间操作时，例如「区间修改」操作，即将指定区间的每一个元素都加上同一个值，如果仍用基本树状数组，我们只能对区间内的每一个元素都执行一次单点修改来实现，易知该操作的时间复杂度为 O(nlogn)O(nlogn) 。接下来我们介绍的 RUPQ BIT 引入差分数组 diff[]diff[] ，使得「区间修改」和「单点查询」操作的时间复杂度均为 O(logn)O(logn) 。



差分数组
「RUPQ BIT」实现的关键是 「差分数组」 。对于大小为 n+1n+1 的输入数组 numsnums ，我们规定 nums[0]=0nums[0]=0 ，其有效数字范围为 [1,n][1,n] 。对差分数组 diff[]diff[] ，有 diff[i] = nums[i] - nums[i - 1]diff[i]=nums[i]−nums[i−1] 。下面我们指出关于差分数组的重要性质。

区间修改: [l, r][l,r] 区间每个元素加 xx 。根据 diffdiff 的定义，numsnums 上完成该区间修改后 (实际不修改 numsnums)，除了 diff[l] += xdiff[l]+=x 、diff[r+1] -= xdiff[r+1]−=x 外，其他 diffdiff 元素值不变，因为区间内做差的两个值都增加了 xx ，差值不变。
单点查询: 由于我们不修改 numsnums 的元素 (否则时间复杂度为 O(n)O(n) )，因此区间修改后，我们将无法再通过 numsnums 来查询单个元素值。但通过下式，我们有 nums[k] = \sum_{i=1}^{k} diff[i]nums[k]=∑ 
i=1
k

 diff[i]，也就是 diffdiff 到第 kk 项的前缀和为 nums[k]nums[k] 。
\begin{aligned} nums[k] &=(nums[k]-nums[k-1])+(nums[k-1]-nums[k-2])+...+(nums[1]-nums[0]) \\ &= diff[k]+diff[k - 1]+...+diff[1] \end{aligned}
nums[k]


=(nums[k]−nums[k−1])+(nums[k−1]−nums[k−2])+...+(nums[1]−nums[0])
=diff[k]+diff[k−1]+...+diff[1]

 

例如 nums = \{0,4,2,-2,7,8\}nums={0,4,2,−2,7,8} (有效数字是 \{4,2,-2,7,8\}{4,2,−2,7,8} )，则 diff =\{0,4,-2,-4,9,1\}diff={0,4,−2,−4,9,1} 。我们对先对 [2,4][2,4] 区间加 3，然后再求 nums[3]nums[3] 。

操作	nums	diff
初始	\{0,4,2,-2,7,8\}{0,4,2,−2,7,8}	\{0,4,-2,-4,9,1\}{0,4,−2,−4,9,1}
[2,4][2,4] 区间加 3	\{0,4,5,1,10,8\}{0,4,5,1,10,8}
※ 实际不修改	\{0,4,1,-4,9,-2\}{0,4,1,−4,9,−2}
nums[3]=diff[1]+diff[2]+diff[3]=1nums[3]=diff[1]+diff[2]+diff[3]=1 ，通过 diffdiff 前缀和完成了单点查询。容易看出，借助「差分数组」，对 numsnums 的区间修改实际上是对 diffdiff 的两次单点修改，的时间复杂度为 O(1)O(1) ，对 numsnums 的单点查询实际上是对 diffdiff 的区间查询 (前缀区间查询)， 时间复杂度为 O(n)O(n) 。

通过上述分析我们发现，如果把 diff[]diff[] 数组看作基本BIT (PURQ) 中的 nums[]nums[] ，那么区间查询时对 diff[l]diff[l] 和 diff[r+1]diff[r+1] 的修改就对应了基本BIT中的 addadd 操作，单点查询则对应基本BIT中的 queryquery 操作。下面我们分析 RUPQ BIT，并给出实现。



从PURQ到RUPQ
快速理解 RUPQ BIT 的关键只需明确一点: RUPQ BIT 中的 tree[]tree[] 对应的是 diff[]diff[] 的所有子区间的区间和。如下是 PURQ BIT 和 RUPQ BIT 的简单对比。

单点修改区间查询 (PURQ)	区间修改单点查询 (RUPQ)
输入数组	nums[]nums[]	nums[]nums[]
前缀区间求解对象	nums[]nums[]	diff[]diff[]
逻辑二元索引树	nums[]nums[] 的所有子区间的区间和构成 tree[]tree[]	diff[]diff[] 的所有子区间的区间和构成 tree[]tree[]
通过「差分数组」的学习，我们知道 RUPQ BIT 的「区间修改」，实际上只需要执行 add(l, x)add(l,x) 以及 add(r+1,x)add(r+1,x) 。我们已经知道，addadd 方法中的 forfor 循环会沿着结点的父链不断更新更大区间的区间和。这一点保证了「单点查询」时， 执行 query(k)query(k) 能够取得正确的 diff[1] \sim diff[k]diff[1]∼diff[k] 的和，也就是 nums[k]nums[k] 。除了需要从 numsnums 求出 diffdiff ，RUPQ BIT 的 addadd 和 queryquery 方法与 PURQ BIT 是完全相同的。



时空复杂度
分析方法及结果均同 PURQ BIT。



类的代码实现

class RUPQBIT { // 区间修改单点查询
    int[] diff, tree; // nums为输入数组，diff为差分数组，tree代表的是 diff 的区间和。
    int n;
    public RUPQBIT(int[] nums){ // 输入的nums有效元素从 nums[1] 开始，共 n 个，nums大小为 n+1
        this.n = nums.length - 1; // 有效元素个数
        this.diff = new int[this.n + 1];
        this.tree = new int[this.n + 1];
        for(int i = 1; i <= n; i++){ // 求diff[]
            diff[i] = nums[i] - nums[i - 1];
        }
        for(int i = 1; i <= n; i++){ // 初始化tree[]
            add(i, diff[i]);
        }
    }
    public void rangeUpdate(int l, int r, int x){ // 区间修改
        add(l, x);
        add(r + 1, -x);
    }
    public int query(int k){ // 单点查询 nums[k]
        int ans = 0;
        for(int i = k; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
            ans += tree[i];
        }
        return ans;
    }
    private void add(int k, int x){ // 为第k个结点tree[k]加上x
        for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
            tree[i] += x; // 包含第k项的区间都加上x
        }
    }
    private int lowbit(int i){
        return i & -i;
    }
}


RURQ BIT (区改区查)
本小节介绍第三种 BIT 。RURQ BIT 以 O(logn)O(logn) 时间复杂度支持「区间修改」及「区间查询」。



从RUPQ到RURQ
该版本的 BIT 在 RUPQ BIT 差分数组的基础上， 通过算式推导发现只需再引入一棵逻辑树即可实现「区间查询」 。推导过程如下。

\begin{aligned} sum(l,r) &= preSum(r)-preSum(l-1) \\ &= (nums[1]+nums[2]+,...,+nums[r])-(nums[1]+nums[2]+...+nums[l-1]) \\ \\ preSum(k)&=nums[1]+nums[2]+,...,+nums[k] \\ &=(diff[1])+(diff[1]+diff[2])+,...,+(diff[1]+diff[2]+,...,+diff[k])\\ &=k*diff[1]+(k-1)*diff[2]+,...,+(k-(k-1))*diff[k] \\ &=k*(diff[1]+diff[2]+,...,+diff[k])\\ &\quad-(0*diff[1]+1*diff[2]+,...,+(k-1)*diff[k]) \end{aligned}
sum(l,r)
preSum(k)


=preSum(r)−preSum(l−1)
=(nums[1]+nums[2]+,...,+nums[r])−(nums[1]+nums[2]+...+nums[l−1])
=nums[1]+nums[2]+,...,+nums[k]
=(diff[1])+(diff[1]+diff[2])+,...,+(diff[1]+diff[2]+,...,+diff[k])
=k∗diff[1]+(k−1)∗diff[2]+,...,+(k−(k−1))∗diff[k]
=k∗(diff[1]+diff[2]+,...,+diff[k])
−(0∗diff[1]+1∗diff[2]+,...,+(k−1)∗diff[k])

 

从 preSum(k)preSum(k) 的推导结果可以看到，减号左边是 kk 倍的 query(k)query(k) (RUPQ BIT)，而右边可以引入一棵新的逻辑树 helperTreehelperTree 来维护数组 helperArr=\{(i-1)*diff[i]\}, i∈[1,n]helperArr={(i−1)∗diff[i]},i∈[1,n] 的区间和，每次区间修改时，同时修改 tree, helperTreetree,helperTree ，如此，便可通过上面给出的式子实现「区间查询」。具体实现请看「类的实现代码」。



时空复杂度
分析方法及结果均同 PURQ BIT。



类的实现代码

class RURQBIT { // 区间修改区间查询
    int[] diff, tree, helperTree; // nums为输入数组，diff为差分数组，tree是diff的区间和构成的逻辑树，helperTree是辅助逻辑树
    int n;
    public RURQBIT(int[] nums){
        this.n = nums.length - 1; // 有效元素个数
        this.diff = new int[n + 1];
        this.tree = new int[n + 1];
        this.helperTree = new int[n + 1];
        for(int i = 1; i <= n; i++){ // 求diff[]
            diff[i] = nums[i] - nums[i - 1];
        }
        for(int i = 1; i <= n; i++){ // 初始化tree[]和helperTree
             add(tree, i, diff[i]);
             add(helperTree, i, (i - 1) * diff[i]);
        }
    }
    // 查询区间和: 求nums[l]到nums[r]之和 preSum(r)-preSum(l-1)
    public int sum(int l, int r){
        int preSum0 = (l - 1) * query(tree, l - 1) - query(helperTree, l - 1);
        int preSum1 = r * query(tree, r) - query(helperTree, r);
        return preSum1 - preSum0;
    }
    public void rangeUpdate(int l, int r, int x){ // 区间修改
        add(tree, l, x);
        add(tree, r + 1, -x);
        add(helperTree, l, (l - 1) * x);
        add(helperTree, r + 1, r * (-x));
    }
    public int query(int[] thisTree, int k){ // 区间查询，求前缀和 preSum[k]
        int ans = 0;
        for(int i = k; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
            ans += thisTree[i];
        }
        return ans;
    }
    private void add(int[] thisTree, int k, int x){ // 为第k个结点thisTree[k]加上x
        for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
            thisTree[i] += x; // 包含第k项的区间都加上x
        }
    }
    private int lowbit(int i){
        return i & -i;
    }
}


小结
关于「树状数组」，总结如下。

基本的树状数组 (PURQ BIT) 以 O(logn)O(logn) 复杂度解决长度为 nn 的序列的 单点修改 及 区间查询 问题。
我们从区间查询出发，思考如何利用类似倍增思想那样的做法来划分子区间，从而提高区间查询的效率。
通过对 numsnums 下标二进制形式的观察，找到了一种将输入序列划分为 nn 个子区间的方式。链接子区间及包含它的更大一点的子区间后，这些子区间构成一棵逻辑上的 「二元索引树」 。
单点修改及区间查询的时间复杂度都与 (n)_2(n) 
2

  的位数相关，简单分析后可知它们都是时间为 O(logn)O(logn) 的操作。
在 PURQ BIT 的基础上，引入 差分数组 ，实现了 RUPQ BIT。
在 RUPQ BIT 的基础上，根据 算式推导 ，引入 辅助树状数组 ，实现了 RURQ BIT。
总结不同方法的 PU/PQ/RU/RQ 操作的时间复杂度如下。

单点修改	单点查询	区间修改	区间查询
普通数组	O(1)O(1)	O(1)O(1)	O(n)O(n)	O(n)O(n)
普通数组+前缀和数组	O(n)O(n)	O(1)O(1)	O(n)O(n)	O(1)O(1)
差分数组	O(1)O(1)	O(n)O(n)	O(1)O(1)	O(n)O(n)
PURQ BIT	★ O(logn)O(logn)	O(1)O(1)	O(nlogn)O(nlogn)	★ O(logn)O(logn)
RUPQ BIT		★ O(logn)O(logn)	★ O(logn)O(logn)	
RURQ BIT			★ O(logn)O(logn)	★ O(logn)O(logn)


实战应用
307. 区域和检索 - 数组可修改 是基本树状数组 (PURQ BIT) 模版题，利用我们给出的代码可轻松解决，详细请看后表中相关题解。下面我们重点介绍巧用树状数组解决的一类常见问题 ── 区间内大小在 [lower, upper][lower,upper] 范围内的元素数 。



区间内在给定取值范围内的元素数
首先从「逆序对」问题开始。求输入数组 numsnums 的逆序对， 是树状数组的经典应用，更是一个「妙用」 ，我们指出，它是本节标题「区间内在给定取值范围内的元素数」的一个应用。以 剑指 Offer 51. 数组中的逆序对 为例，树状数组解法代码见 题解，可以看到，其中的 BIT 类与我们在前面提供的 PURQ BIT 类的实现代码几乎相同。但我们注意到，在主方法 (reversePairsreversePairs) 中，调用 addadd 时，传入的增量 xx 是固定的 1。我们知道对于一般的 BIT， nums[k -1]nums[k−1] 增加 xx 后，调用 add(k,x)add(k,x) ，从第一个包含 nums[k-1]nums[k−1] 的区间的区间和开始，都增加 xx ，即从 tree[k]+=xtree[k]+=x 开始，沿着父链更新所有包含 nums[k-1]nums[k−1] 的区间和。那么 add(nums[i], 1)add(nums[i],1) 是什么意思呢？

先看 numsnums ，在执行 add(nums[i],1)add(nums[i],1) 之前，原大小为 nn 的输入数组 numsnums 已由 「离散化」 操作变为了这样一个数组:

离散化后的 numsnums 的所有元素的取值范围变为 [1,n][1,n] (指松离散，另外还有紧离散，见后续)，且任意一对 nums[i]nums[i] 与 nums[j]nums[j] 的大小关系与原 numsnums 中 nums[i]nums[i] 与 nums[j]nums[j] 的大小关系一致。

例如 \{-2,6,-10\}{−2,6,−10} 离散化后为 \{2,3,1\}{2,3,1} 。

接着分析 add(nums[i], 1)add(nums[i],1) 的含义。这个操作是在遍历 numsnums 过程中进行的，实际动作是对于 nums[i]nums[i] ，从 tree[nums[i]]tree[nums[i]] 开始，沿着父链上升，使得包含下标 nums[i]nums[i] 的代表更大区间的 tree[x]+= 1tree[x]+=1 。treetree 的 [1,n][1,n] 下标与 numsnums 元素值的大小范围一致。 addadd 的这一操作，相当于加入 nums[i]nums[i] 时，告知 numsnums 中在 ii 之后的比 nums[i]nums[i] 更大的数，在它前面新增了一个小于它的数。有点难以理解，没关系，结合下图，我们实际操作一下。


按照上述方式对 nums = {3,1,5,4,7,8,6,2} 中的元素依次执行 add(nums[i],1)
① add(3, 1)
② add(1, 1)
③ add(5, 1)
④ add(4, 1)
⑤ add(7, 1)
⑥ add(8, 1)
⑦ add(6, 1)
⑧ add(2, 1)


我们发现，每次加入一个 nums[i]nums[i] 之后，我们总是能够 通过前缀和查询当前「小于等于」某个数的元素个数 。例如，第 ④ 步过后，「小于等于」3 的个数，为 query(3) = 2query(3)=2 。第 ⑥ 步过后「小于等于」7 的个数，为 query(4)=5query(4)=5 。而当我们问介于 [lower, upper][lower,upper] 之间的数有多少个时，实际上就是求 query(upper) - query(lower - 1)query(upper)−query(lower−1) 。 还需注意的是， lower, upperlower,upper 的取值范围要在 [1,n][1,n] 之间，否则查询越界 (在 327. 区间和的个数 中我们将看到查询范围超过 [1,n][1,n] 时该如何处理)。

总之，我们将一个 numsnums 离散化后，遍历它，先执行 query(x)query(x) ，再执行 add(nums[i], 1)add(nums[i],1)，这个操作即为每次添加 nums[i]nums[i] 前询问当前 numsnums 中小于等于 xx 的元素个数。又因为我们总是先询问然后再插入第 ii 个元素，那么，在插入 nums[i]nums[i] 之前:

若执行 query(upper)query(upper) ，即为询问 nums[0]nums[0] 到 nums[i-1]nums[i−1] 中，小于等于 upperupper 的个数；
若执行 query(lower-1)query(lower−1) ，即为询问 nums[0]nums[0] 到 nums[i-1]nums[i−1] 中，小于等于 lower - 1lower−1 的个数；
若执行 query(upper)-query(lower-1)query(upper)−query(lower−1) ，即为询问 nums[0]nums[0] 到 nums[i-1]nums[i−1] 中，取值范围为 [lower,upper][lower,upper] 的元素个数。
这就是本小节标题所谓的「区间内在给定取值范围内的元素数」 的含义，区间指 [0,i-1][0,i−1] 区间，给定取值范围指 [lower, upper][lower,upper] 。

现在分析「逆序对」问题就简单多了。由于离散化不改变任意一对元素的大小关系，因此 对原数组求逆序数等同于对离散化后的数组求逆序数 。我们要做的是询问 nums[i]nums[i] 的前面，有多少个大于它的数，刚好相当于在 numsnums 中插入 nums[i]nums[i] 之前， 求 i - query(nums[i])i−query(nums[i]) 。即 [0,i-1][0,i−1] 范围内，有 ii 个数，其中「小于等于」nums[i]nums[i] 的有 query(nums[i])query(nums[i]) 个，因此 i - query(nums[i])i−query(nums[i]) 即为所求。

在完全理解了「遍历离散化后的 numsnums ，在遍历过程中查询 query(x)query(x) ，查询后通过 add(nums[i],1)add(nums[i],1) 插入 nums[i]nums[i]」 这一操作的意义后，类似的题目如下:

315. 计算右侧小于当前元素的个数 题，与「逆序数」问题的区别仅在此题要求解「小于」，逆序数问题中涉及的是「小于等于」，只需要在「小于等于」版本的代码上做简单调整即可，详情见题解。
406. 根据身高重建队列 也是用树状数组求对于当前元素它之前的「小于等于」它的元素个数的问题，具体实现需结合二分查找，这是树状数组与其他方法相结合的一个好例子。
493. 翻转对 。「逆序对」的变形题，query(x)query(x) 中 xx 的范围超过了离散化后 numsnums 的取值范围，这一点类似 327 题，可能被查询的数值要与原 numsnums 中的数一起离散化。
327. 区间和的个数 。此题是更进阶的题目，不仅求解对象从 numsnums 变成了 preSumspreSums ，lower, upperlower,upper 的范围也不再是 [1,n][1,n] (nn 是 numsnums 的大小) 。这道题细节处理较多，详细内容请看题解。
关于这几题的详细题解和更多的树状数组题目，请参考后表。



松离散与紧离散
在前面的分析中，我们提到了「离散化」的概念，即在题目只关心输入数组 numsnums 元素的大小关系而不关心具体的值时，为了压缩空间，我们先将 numsnums 离散化。常见的离散化方式有两种，它们都基于排序，但其中一种借助了 setset 去重，使得离散化后的有效数字更少，取值范围更小，我把这种方式称为「紧离散」；另一种则没有去重，因此离散化后的有效数字更多 (存在相同的数字)，取值范围也更大，我称之为「松离散」。以下是两种离散化方式的实现。


// 松离散
private void discrete(int[] nums){ 
    int n = nums.length;
    int[] tmp = new int[n];
    System.arraycopy(nums, 0, tmp, 0, n);
    Arrays.sort(tmp);
    for (int i = 0; i < n; ++i) {
        nums[i] = Arrays.binarySearch(tmp, nums[i]) + 1;
    }
}

// 紧离散
private Map<Integer, Integer> discrete(int[] nums){ 
    Map<Integer, Integer> map = new HashMap<>();
    Set<Integer> set = new HashSet<>();
    for(int num : nums) set.add(num);
    List<Integer> list = new ArrayList<>(set);
    Collections.sort(list);
    int idx = 0;
    for(int num : list) map.put(num, ++idx);
    return map;
}
例如对于 nums=\{2,4,4,6\}nums={2,4,4,6} ，松离散得到 nums=\{1,2,2,4\}nums={1,2,2,4}，离散化后的 numsnums 大小与原来相同；紧离散得到 map=\{(2,1),(4,2),(6,3)\}map={(2,1),(4,2),(6,3)} ， keykey 为 numsnums 中的元素，对应的 valuevalue 为其离散化值，valuevalue 一定是从 1 开始的没有重复的连续正整数。两种方式离散化后虽然有效数字不同，取值范围也不同，但求解结果都是正确的 (读者可以思考一下为什么)。松离散无需哈希计算，通常速度更快，但有的题目可能更适合返回 mapmap 的紧离散 (例如 327. 区间和的个数 和 493. 翻转对 )。



题目
题目	难度	题解
307. 区域和检索 - 数组可修改
※ PURQBIT模版题	中等	题解
剑指 Offer 51. 数组中的逆序对	困难	题解
315. 计算右侧小于当前元素的个数	困难	题解
406. 根据身高重建队列	中等	题解
493. 翻转对	困难	题解
327. 区间和的个数	困难	题解
P3368 【模板】树状数组 2
※ 给出的 RUPQBIT 类代码调整为 long 类型后可解决，但有若干用例TLE		模版题
132. 树状数组 3
※ 给出的 RURQBIT 类代码调整为 long 类型后可解决，但有若干用例TLE		模版题

作者：yukiyama
链接：https://leetcode.cn/circle/discuss/qGREiN/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。